//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by CodeSmith.
//
//     Date:    1/13/2010
//     Time:    10:19 PM
//     Version: 5.0.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Collections;

namespace HongPhat.DataAccess
{
    #region ORDERS_FindRowCollection
    #region Interface IORDERS_FindRowCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="ORDERS_FindRow"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IORDERS_FindRowCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="ORDERS_FindRow"/> elements.
    /// </remarks>

    public interface IORDERS_FindRowCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IORDERS_FindRowCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IORDERS_FindRowCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IORDERS_FindRowCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IORDERS_FindRowCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IORDERS_FindRowCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IORDERS_FindRowCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IORDERS_FindRowCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="ORDERS_FindRow"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ORDERS_FindRow"/> elements copied from the <see cref="IORDERS_FindRowCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IORDERS_FindRowCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(ORDERS_FindRow[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IORDERS_FindRowEnumerator"/> that can
        /// iterate through the <see cref="IORDERS_FindRowCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IORDERS_FindRowEnumerator"/>
        /// for the entire <see cref="IORDERS_FindRowCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IORDERS_FindRowEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IORDERS_FindRowList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="ORDERS_FindRow"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IORDERS_FindRowList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="ORDERS_FindRow"/> elements.
    /// </remarks>

    public interface
        IORDERS_FindRowList: IORDERS_FindRowCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IORDERS_FindRowList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IORDERS_FindRowList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IORDERS_FindRowList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IORDERS_FindRowList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="ORDERS_FindRow"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="ORDERS_FindRow"/> element to get or set.</param>
        /// <value>
        /// The <see cref="ORDERS_FindRow"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IORDERS_FindRowCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IORDERS_FindRowList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        ORDERS_FindRow this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="ORDERS_FindRow"/> to the end
        /// of the <see cref="IORDERS_FindRowList"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to be added to the end of the <see cref="IORDERS_FindRowList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IORDERS_FindRowList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IORDERS_FindRowList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IORDERS_FindRowList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(ORDERS_FindRow value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IORDERS_FindRowList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IORDERS_FindRowList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IORDERS_FindRowList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IORDERS_FindRowList"/>
        /// contains the specified <see cref="ORDERS_FindRow"/> element.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to locate in the <see cref="IORDERS_FindRowList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IORDERS_FindRowList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(ORDERS_FindRow value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="ORDERS_FindRow"/> in the <see cref="IORDERS_FindRowList"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to locate in the <see cref="IORDERS_FindRowList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IORDERS_FindRowList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(ORDERS_FindRow value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="ORDERS_FindRow"/> element into the
        /// <see cref="IORDERS_FindRowList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to insert into the <see cref="IORDERS_FindRowList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IORDERS_FindRowCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IORDERS_FindRowList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IORDERS_FindRowList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, ORDERS_FindRow value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="ORDERS_FindRow"/>
        /// from the <see cref="IORDERS_FindRowList"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to remove from the <see cref="IORDERS_FindRowList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IORDERS_FindRowList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IORDERS_FindRowList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(ORDERS_FindRow value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IORDERS_FindRowList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IORDERS_FindRowCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IORDERS_FindRowList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IORDERS_FindRowList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IORDERS_FindRowEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="ORDERS_FindRow"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IORDERS_FindRowEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="ORDERS_FindRow"/> elements.
    /// </remarks>

    public interface IORDERS_FindRowEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="ORDERS_FindRow"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="ORDERS_FindRow"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        ORDERS_FindRow Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Class ORDERS_FindRowCollection

    /// <summary>
    /// Implements a strongly typed collection of <see cref="ORDERS_FindRow"/> elements.
    /// </summary>
    /// <remarks><para>
    /// <b>ORDERS_FindRowCollection</b> provides an <see cref="ArrayList"/>
    /// that is strongly typed for <see cref="ORDERS_FindRow"/> elements.
    /// </para></remarks>

    [Serializable]
    public class ORDERS_FindRowCollection:
        IORDERS_FindRowList, IList, ICloneable {
        #region Private Fields

        private const int _defaultCapacity = 16;

        private ORDERS_FindRow[] _array = null;
        private int _count = 0;

        [NonSerialized]
        private int _version = 0;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private ORDERS_FindRowCollection(Tag tag) { }

        #endregion
        #region Public Constructors
        #region ORDERS_FindRowCollection()

        /// <overloads>
        /// Initializes a new instance of the <see cref="ORDERS_FindRowCollection"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="ORDERS_FindRowCollection"/> class
        /// that is empty and has the default initial capacity.
        /// </summary>
        /// <remarks>Please refer to <see cref="ArrayList()"/> for details.</remarks>

        public ORDERS_FindRowCollection() {
            this._array = new ORDERS_FindRow[_defaultCapacity];
        }

        #endregion
        #region ORDERS_FindRowCollection(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="ORDERS_FindRowCollection"/> class
        /// that is empty and has the specified initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new
        /// <see cref="ORDERS_FindRowCollection"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(Int32)"/> for details.</remarks>

        public ORDERS_FindRowCollection(int capacity) {
            if (capacity < 0)
                throw new ArgumentOutOfRangeException("capacity",
                    capacity, "Argument cannot be negative.");

            this._array = new ORDERS_FindRow[capacity];
        }

        #endregion
        #region ORDERS_FindRowCollection(ORDERS_FindRowCollection)

        /// <summary>
        /// Initializes a new instance of the <see cref="ORDERS_FindRowCollection"/> class
        /// that contains elements copied from the specified collection and
        /// that has the same initial capacity as the number of elements copied.
        /// </summary>
        /// <param name="collection">The <see cref="ORDERS_FindRowCollection"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(ICollection)"/> for details.</remarks>

        public ORDERS_FindRowCollection(ORDERS_FindRowCollection collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            this._array = new ORDERS_FindRow[collection.Count];
            AddRange(collection);
        }

        #endregion
        #region ORDERS_FindRowCollection(ORDERS_FindRow[])

        /// <summary>
        /// Initializes a new instance of the <see cref="ORDERS_FindRowCollection"/> class
        /// that contains elements copied from the specified <see cref="ORDERS_FindRow"/>
        /// array and that has the same initial capacity as the number of elements copied.
        /// </summary>
        /// <param name="array">An <see cref="Array"/> of <see cref="ORDERS_FindRow"/>
        /// elements that are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(ICollection)"/> for details.</remarks>

        public ORDERS_FindRowCollection(ORDERS_FindRow[] array) {
            if (array == null)
                throw new ArgumentNullException("array");

            this._array = new ORDERS_FindRow[array.Length];
            AddRange(array);
        }

        #endregion
        #endregion
        #region Protected Properties
        #region InnerArray
        
        /// <summary>
        /// Gets the list of elements contained in the <see cref="ORDERS_FindRowCollection"/> instance.
        /// </summary>
        /// <value>
        /// A one-dimensional <see cref="Array"/> with zero-based indexing that contains all 
        /// <see cref="ORDERS_FindRow"/> elements in the <see cref="ORDERS_FindRowCollection"/>.
        /// </value>
        /// <remarks>
        /// Use <b>InnerArray</b> to access the element array of a <see cref="ORDERS_FindRowCollection"/>
        /// instance that might be a read-only or synchronized wrapper. This is necessary because
        /// the element array field of wrapper classes is always a null reference.
        /// </remarks>

        protected virtual ORDERS_FindRow[] InnerArray {
            get { return this._array; }
        }

        #endregion
        #endregion
        #region Public Properties
        #region Capacity

        /// <summary>
        /// Gets or sets the capacity of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <value>The number of elements that the
        /// <see cref="ORDERS_FindRowCollection"/> can contain.</value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <b>Capacity</b> is set to a value that is less than <see cref="Count"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Capacity"/> for details.</remarks>

        public virtual int Capacity {
            get { return this._array.Length; }
            set {
                if (value == this._array.Length) return;

                if (value < this._count)
                    throw new ArgumentOutOfRangeException("Capacity",
                        value, "Value cannot be less than Count.");

                if (value == 0) {
                    this._array = new ORDERS_FindRow[_defaultCapacity];
                    return;
                }

                ORDERS_FindRow[] newArray = new ORDERS_FindRow[value];
                Array.Copy(this._array, newArray, this._count);
                this._array = newArray;
            }
        }

        #endregion
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <value>
        /// The number of elements contained in the <see cref="ORDERS_FindRowCollection"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="ArrayList.Count"/> for details.</remarks>

        public virtual int Count {
            get { return this._count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="ORDERS_FindRowCollection"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ORDERS_FindRowCollection"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsFixedSize"/> for details.</remarks>

        public virtual bool IsFixedSize {
            get { return false; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="ORDERS_FindRowCollection"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ORDERS_FindRowCollection"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsReadOnly"/> for details.</remarks>

        public virtual bool IsReadOnly {
            get { return false; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="ORDERS_FindRowCollection"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="ORDERS_FindRowCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsSynchronized"/> for details.</remarks>

        public virtual bool IsSynchronized {
            get { return false; }
        }

        #endregion
		#region IsUnique

		/// <summary>
		/// Gets a value indicating whether the <see cref="ORDERS_FindRowCollection"/> 
		/// ensures that all elements are unique.
		/// </summary>
		/// <value>
		/// <c>true</c> if the <see cref="ORDERS_FindRowCollection"/> ensures that all 
		/// elements are unique; otherwise, <c>false</c>. The default is <c>false</c>.
		/// </value>
		/// <remarks>
		/// <b>IsUnique</b> returns <c>true</c> exactly if the <see cref="ORDERS_FindRowCollection"/>
		/// is exposed through a <see cref="Unique"/> wrapper. 
		/// Please refer to <see cref="Unique"/> for details.
		/// </remarks>

		public virtual bool IsUnique {
			get { return false; }
		}

		#endregion
        #region Item: ORDERS_FindRow

        /// <summary>
        /// Gets or sets the <see cref="ORDERS_FindRow"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="ORDERS_FindRow"/> element to get or set.</param>
        /// <value>
        /// The <see cref="ORDERS_FindRow"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException"><para>
        /// The property is set and the <see cref="ORDERS_FindRowCollection"/> is read-only.
        /// </para><para>-or-</para><para>
        /// The property is set, the <b>ORDERS_FindRowCollection</b> already contains the
        /// specified element at a different index, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.this"/> for details.</remarks>

        public virtual ORDERS_FindRow this[int index] {
            get {
                ValidateIndex(index);
                return this._array[index];
            }
            set {
                ValidateIndex(index);
                ++this._version;
                this._array[index] = value;
            }
        }

        #endregion
        #region IList.Item: Object

        /// <summary>
        /// Gets or sets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <value>
        /// The element at the specified <paramref name="index"/>. When the property
        /// is set, this value must be compatible with <see cref="ORDERS_FindRow"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="InvalidCastException">The property is set to a value
        /// that is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <exception cref="NotSupportedException"><para>
        /// The property is set and the <see cref="ORDERS_FindRowCollection"/> is read-only.
        /// </para><para>-or-</para><para>
        /// The property is set, the <b>ORDERS_FindRowCollection</b> already contains the
        /// specified element at a different index, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.this"/> for details.</remarks>

        object IList.this[int index] {
            get { return this[index]; }
            set { this[index] = (ORDERS_FindRow) value; }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="ORDERS_FindRowCollection"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="ArrayList.SyncRoot"/> for details.</remarks>

        public virtual object SyncRoot {
            get { return this; }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(ORDERS_FindRow)

        /// <summary>
        /// Adds a <see cref="ORDERS_FindRow"/> to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to be added to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="ORDERS_FindRowCollection"/> index at which the
        /// <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains the specified
        /// <paramref name="value"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Add"/> for details.</remarks>

        public virtual int Add(ORDERS_FindRow value) {
            if (this._count == this._array.Length)
                EnsureCapacity(this._count + 1);

            ++this._version;
            this._array[this._count] = value;
            return this._count++;
        }

        #endregion
        #region IList.Add(Object)

        /// <summary>
        /// Adds an <see cref="Object"/> to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">
        /// The object to be added to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument must be compatible with <see cref="ORDERS_FindRow"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="ORDERS_FindRowCollection"/> index at which the
        /// <paramref name="value"/> has been added.</returns>
        /// <exception cref="InvalidCastException"><paramref name="value"/>
        /// is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains the specified
        /// <paramref name="value"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Add"/> for details.</remarks>

        int IList.Add(object value) {
            return Add((ORDERS_FindRow) value);
        }

        #endregion
        #region AddRange(ORDERS_FindRowCollection)

        /// <overloads>
        /// Adds a range of elements to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// </overloads>
        /// <summary>
        /// Adds the elements of another collection to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="collection">The <see cref="ORDERS_FindRowCollection"/> whose elements
        /// should be added to the end of the current collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains one or more elements
        /// in the specified <paramref name="collection"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.AddRange"/> for details.</remarks>

        public virtual void AddRange(ORDERS_FindRowCollection collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            if (collection.Count == 0) return;
            if (this._count + collection.Count > this._array.Length)
                EnsureCapacity(this._count + collection.Count);

            ++this._version;
            Array.Copy(collection.InnerArray, 0,
                this._array, this._count, collection.Count);
            this._count += collection.Count;
        }

        #endregion
        #region AddRange(ORDERS_FindRow[])

        /// <summary>
        /// Adds the elements of a <see cref="ORDERS_FindRow"/> array
        /// to the end of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="array">An <see cref="Array"/> of <see cref="ORDERS_FindRow"/> elements
        /// that should be added to the end of the <see cref="ORDERS_FindRowCollection"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains one or more elements
        /// in the specified <paramref name="array"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.AddRange"/> for details.</remarks>

        public virtual void AddRange(ORDERS_FindRow[] array) {
            if (array == null)
                throw new ArgumentNullException("array");

            if (array.Length == 0) return;
            if (this._count + array.Length > this._array.Length)
                EnsureCapacity(this._count + array.Length);

            ++this._version;
            Array.Copy(array, 0, this._array, this._count, array.Length);
            this._count += array.Length;
        }

        #endregion
        #region BinarySearch

        /// <summary>
        /// Searches the entire sorted <see cref="ORDERS_FindRowCollection"/> for an
        /// <see cref="ORDERS_FindRow"/> element using the default comparer
        /// and returns the zero-based index of the element.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to locate in the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The zero-based index of <paramref name="value"/> in the sorted
        /// <see cref="ORDERS_FindRowCollection"/>, if <paramref name="value"/> is found;
        /// otherwise, a negative number, which is the bitwise complement of the index
        /// of the next element that is larger than <paramref name="value"/> or, if there
        /// is no larger element, the bitwise complement of <see cref="Count"/>.</returns>
        /// <exception cref="InvalidOperationException">
        /// Neither <paramref name="value"/> nor the elements of the <see cref="ORDERS_FindRowCollection"/>
        /// implement the <see cref="IComparable"/> interface.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.BinarySearch"/> for details.</remarks>

        public virtual int BinarySearch(ORDERS_FindRow value) {
            return Array.BinarySearch(this._array, 0, this._count, value);
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Clear"/> for details.</remarks>

        public virtual void Clear() {
            if (this._count == 0) return;

            ++this._version;
            Array.Clear(this._array, 0, this._count);
            this._count = 0;
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="ORDERS_FindRowCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.Clone"/> for details.</remarks>

        public virtual object Clone() {
            ORDERS_FindRowCollection collection = new ORDERS_FindRowCollection(this._count);

            Array.Copy(this._array, 0, collection._array, 0, this._count);
            collection._count = this._count;
            collection._version = this._version;

            return collection;
        }

        #endregion
        #region Contains(ORDERS_FindRow)

        /// <summary>
        /// Determines whether the <see cref="ORDERS_FindRowCollection"/>
        /// contains the specified <see cref="ORDERS_FindRow"/> element.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to locate in the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="ORDERS_FindRowCollection"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.Contains"/> for details.</remarks>

        public bool Contains(ORDERS_FindRow value) {
            return (IndexOf(value) >= 0);
        }

        #endregion
        #region IList.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="ORDERS_FindRowCollection"/> contains the specified element.
        /// </summary>
        /// <param name="value">The object to locate in the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument must be compatible with <see cref="ORDERS_FindRow"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="ORDERS_FindRowCollection"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="InvalidCastException"><paramref name="value"/>
        /// is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Contains"/> for details.</remarks>

        bool IList.Contains(object value) {
            return Contains((ORDERS_FindRow) value);
        }

        #endregion
        #region CopyTo(ORDERS_FindRow[])

        /// <overloads>
        /// Copies the <see cref="ORDERS_FindRowCollection"/> or a portion of it to a one-dimensional array.
        /// </overloads>
        /// <summary>
        /// Copies the entire <see cref="ORDERS_FindRowCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="ORDERS_FindRow"/> elements, starting at the beginning of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ORDERS_FindRow"/> elements copied from the <see cref="ORDERS_FindRowCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentException">
        /// The number of elements in the source <see cref="ORDERS_FindRowCollection"/> is greater
        /// than the available space in the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.CopyTo"/> for details.</remarks>

        public virtual void CopyTo(ORDERS_FindRow[] array) {
            CheckTargetArray(array, 0);
            Array.Copy(this._array, array, this._count);
        }

        #endregion
        #region CopyTo(ORDERS_FindRow[], Int32)

        /// <summary>
        /// Copies the entire <see cref="ORDERS_FindRowCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="ORDERS_FindRow"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ORDERS_FindRow"/> elements copied from the <see cref="ORDERS_FindRowCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ORDERS_FindRowCollection"/> is greater than the
        /// available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.CopyTo"/> for details.</remarks>

        public virtual void CopyTo(ORDERS_FindRow[] array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            Array.Copy(this._array, 0, array, arrayIndex, this._count);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="ORDERS_FindRowCollection"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ORDERS_FindRow"/> elements copied from the <see cref="ORDERS_FindRowCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ORDERS_FindRowCollection"/> is greater than the
        /// available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="ORDERS_FindRow"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((ORDERS_FindRow[]) array, arrayIndex);
        }

        #endregion
        #region GetEnumerator: IORDERS_FindRowEnumerator

        /// <summary>
        /// Returns an <see cref="IORDERS_FindRowEnumerator"/> that can
        /// iterate through the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IORDERS_FindRowEnumerator"/>
        /// for the entire <see cref="ORDERS_FindRowCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.GetEnumerator"/> for details.</remarks>

        public virtual IORDERS_FindRowEnumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="ORDERS_FindRowCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region IndexOf(ORDERS_FindRow)

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="ORDERS_FindRow"/> in the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to locate in the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="ORDERS_FindRowCollection"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="ArrayList.IndexOf"/> for details.</remarks>

        public virtual int IndexOf(ORDERS_FindRow value) {
            return Array.IndexOf(this._array, value, 0, this._count);
        }

        #endregion
        #region IList.IndexOf(Object)

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="Object"/> in the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">The object to locate in the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument must be compatible with <see cref="ORDERS_FindRow"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="ORDERS_FindRowCollection"/>, if found; otherwise, -1.
        /// </returns>
        /// <exception cref="InvalidCastException"><paramref name="value"/>
        /// is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.IndexOf"/> for details.</remarks>

        int IList.IndexOf(object value) {
            return IndexOf((ORDERS_FindRow) value);
        }

        #endregion
        #region Insert(Int32, ORDERS_FindRow)

        /// <summary>
        /// Inserts a <see cref="ORDERS_FindRow"/> element into the
        /// <see cref="ORDERS_FindRowCollection"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="value"/>
        /// should be inserted.</param>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to insert into the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains the specified
        /// <paramref name="value"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Insert"/> for details.</remarks>

        public virtual void Insert(int index, ORDERS_FindRow value) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (index > this._count)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot exceed Count.");

            if (this._count == this._array.Length)
                EnsureCapacity(this._count + 1);

            ++this._version;
            if (index < this._count)
                Array.Copy(this._array, index,
                    this._array, index + 1, this._count - index);

            this._array[index] = value;
            ++this._count;
        }

        #endregion
        #region IList.Insert(Int32, Object)

        /// <summary>
        /// Inserts an element into the <see cref="ORDERS_FindRowCollection"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="value"/>
        /// should be inserted.</param>
        /// <param name="value">The object to insert into the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument must be compatible with <see cref="ORDERS_FindRow"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="InvalidCastException"><paramref name="value"/>
        /// is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> already contains the specified
        /// <paramref name="value"/>, and the <b>ORDERS_FindRowCollection</b>
        /// ensures that all elements are unique.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Insert"/> for details.</remarks>

        void IList.Insert(int index, object value) {
            Insert(index, (ORDERS_FindRow) value);
        }

        #endregion
        #region ReadOnly

        /// <summary>
        /// Returns a read-only wrapper for the specified <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="collection">The <see cref="ORDERS_FindRowCollection"/> to wrap.</param>
        /// <returns>A read-only wrapper around <paramref name="collection"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.ReadOnly"/> for details.</remarks>

        public static ORDERS_FindRowCollection ReadOnly(ORDERS_FindRowCollection collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            return new ReadOnlyList(collection);
        }

        #endregion
        #region Remove(ORDERS_FindRow)

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="ORDERS_FindRow"/>
        /// from the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">The <see cref="ORDERS_FindRow"/> object
        /// to remove from the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Remove"/> for details.</remarks>

        public virtual void Remove(ORDERS_FindRow value) {
            int index = IndexOf(value);
            if (index >= 0) RemoveAt(index);
        }

        #endregion
        #region IList.Remove(Object)

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="Object"/>
        /// from the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="value">The object to remove from the <see cref="ORDERS_FindRowCollection"/>.
        /// This argument must be compatible with <see cref="ORDERS_FindRow"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="InvalidCastException"><paramref name="value"/>
        /// is not compatible with <see cref="ORDERS_FindRow"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Remove"/> for details.</remarks>

        void IList.Remove(object value) {
            Remove((ORDERS_FindRow) value);
        }

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.RemoveAt"/> for details.</remarks>

        public virtual void RemoveAt(int index) {
            ValidateIndex(index);

            ++this._version;
            if (index < --this._count)
                Array.Copy(this._array, index + 1,
                    this._array, index, this._count - index);

            this._array[this._count] = null;
        }

        #endregion
        #region RemoveRange

        /// <summary>
        /// Removes the specified range of elements from the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="index">The zero-based starting index of the range
        /// of elements to remove.</param>
        /// <param name="count">The number of elements to remove.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="index"/> and <paramref name="count"/> do not denote a
        /// valid range of elements in the <see cref="ORDERS_FindRowCollection"/>.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="count"/> is less than zero.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.RemoveRange"/> for details.</remarks>

        public virtual void RemoveRange(int index, int count) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (count < 0)
                throw new ArgumentOutOfRangeException("count",
                    count, "Argument cannot be negative.");

            if (index + count > this._count)
                throw new ArgumentException(
                    "Arguments denote invalid range of elements.");

            if (count == 0) return;

            ++this._version;
            this._count -= count;

            if (index < this._count)
                Array.Copy(this._array, index + count,
                    this._array, index, this._count - index);

            Array.Clear(this._array, this._count, count);
        }

        #endregion
        #region Reverse()

        /// <overloads>
        /// Reverses the order of the elements in the 
        /// <see cref="ORDERS_FindRowCollection"/> or a portion of it.
        /// </overloads>
        /// <summary>
        /// Reverses the order of the elements in the entire <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// The <see cref="ORDERS_FindRowCollection"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Reverse"/> for details.</remarks>

        public virtual void Reverse() {
           if (this._count <= 1) return;
           ++this._version;
           Array.Reverse(this._array, 0, this._count);
        }

        #endregion
        #region Reverse(Int32, Int32)

        /// <summary>
        /// Reverses the order of the elements in the specified range.
        /// </summary>
        /// <param name="index">The zero-based starting index of the range
        /// of elements to reverse.</param>
        /// <param name="count">The number of elements to reverse.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="index"/> and <paramref name="count"/> do not denote a
        /// valid range of elements in the <see cref="ORDERS_FindRowCollection"/>.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="count"/> is less than zero.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="ORDERS_FindRowCollection"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Reverse"/> for details.</remarks>

        public virtual void Reverse(int index, int count) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (count < 0)
                throw new ArgumentOutOfRangeException("count",
                    count, "Argument cannot be negative.");

            if (index + count > this._count)
                throw new ArgumentException(
                    "Arguments denote invalid range of elements.");

           if (count <= 1 || this._count <= 1) return;
           ++this._version;
           Array.Reverse(this._array, index, count);
        }

        #endregion
        #region Sort()

        /// <overloads>
        /// Sorts the elements in the <see cref="ORDERS_FindRowCollection"/> or a portion of it.
        /// </overloads>
        /// <summary>
        /// Sorts the elements in the entire <see cref="ORDERS_FindRowCollection"/>
        /// using the <see cref="IComparable"/> implementation of each element.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// The <see cref="ORDERS_FindRowCollection"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Sort"/> for details.</remarks>

        public virtual void Sort() {
            if (this._count <= 1) return;
            ++this._version;
            Array.Sort(this._array, 0, this._count);
        }

        #endregion
        #region Sort(IComparer)

        /// <summary>
        /// Sorts the elements in the entire <see cref="ORDERS_FindRowCollection"/>
        /// using the specified <see cref="IComparer"/> interface.
        /// </summary>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> implementation to use when comparing elements.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the <see cref="IComparable"/> implementation 
        /// of each element.</para></param>
        /// <exception cref="NotSupportedException">
        /// The <see cref="ORDERS_FindRowCollection"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Sort"/> for details.</remarks>

        public virtual void Sort(IComparer comparer) {
            if (this._count <= 1) return;
            ++this._version;
            Array.Sort(this._array, 0, this._count, comparer);
        }

        #endregion
        #region Sort(Int32, Int32, IComparer)

        /// <summary>
        /// Sorts the elements in the specified range 
        /// using the specified <see cref="IComparer"/> interface.
        /// </summary>
        /// <param name="index">The zero-based starting index of the range
        /// of elements to sort.</param>
        /// <param name="count">The number of elements to sort.</param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> implementation to use when comparing elements.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the <see cref="IComparable"/> implementation 
        /// of each element.</para></param>
        /// <exception cref="ArgumentException">
        /// <paramref name="index"/> and <paramref name="count"/> do not denote a
        /// valid range of elements in the <see cref="ORDERS_FindRowCollection"/>.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="count"/> is less than zero.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="ORDERS_FindRowCollection"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Sort"/> for details.</remarks>

        public virtual void Sort(int index, int count, IComparer comparer) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (count < 0)
                throw new ArgumentOutOfRangeException("count",
                    count, "Argument cannot be negative.");

            if (index + count > this._count)
                throw new ArgumentException(
                    "Arguments denote invalid range of elements.");

           if (count <= 1 || this._count <= 1) return;
            ++this._version;
            Array.Sort(this._array, index, count, comparer);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <param name="collection">The <see cref="ORDERS_FindRowCollection"/> to synchronize.</param>
        /// <returns>
        /// A synchronized (thread-safe) wrapper around <paramref name="collection"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Synchronized"/> for details.</remarks>

        public static ORDERS_FindRowCollection Synchronized(ORDERS_FindRowCollection collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            return new SyncList(collection);
        }

        #endregion
        #region ToArray

        /// <summary>
        /// Copies the elements of the <see cref="ORDERS_FindRowCollection"/> to a new
        /// <see cref="Array"/> of <see cref="ORDERS_FindRow"/> elements.
        /// </summary>
        /// <returns>A one-dimensional <see cref="Array"/> of <see cref="ORDERS_FindRow"/>
        /// elements containing copies of the elements of the <see cref="ORDERS_FindRowCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.ToArray"/> for details.</remarks>

        public virtual ORDERS_FindRow[] ToArray() {
            ORDERS_FindRow[] array = new ORDERS_FindRow[this._count];
            Array.Copy(this._array, array, this._count);
            return array;
        }

        #endregion
        #region TrimToSize

        /// <summary>
        /// Sets the capacity to the actual number of elements in the <see cref="ORDERS_FindRowCollection"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ORDERS_FindRowCollection"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ORDERS_FindRowCollection</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.TrimToSize"/> for details.</remarks>

        public virtual void TrimToSize() {
            Capacity = this._count;
        }

        #endregion
        #region Unique

        /// <summary>
        /// Returns a wrapper for the specified <see cref="ORDERS_FindRowCollection"/>
        /// ensuring that all elements are unique.
        /// </summary>
        /// <param name="collection">The <see cref="ORDERS_FindRowCollection"/> to wrap.</param>    
        /// <returns>
        /// A wrapper around <paramref name="collection"/> ensuring that all elements are unique.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="collection"/> contains duplicate elements.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks><para>
        /// The <b>Unique</b> wrapper provides a set-like collection by ensuring
        /// that all elements in the <see cref="ORDERS_FindRowCollection"/> are unique.
        /// </para><para>
        /// <b>Unique</b> raises an <see cref="ArgumentException"/> if the specified 
        /// <paramref name="collection"/> contains any duplicate elements. The returned
        /// wrapper raises a <see cref="NotSupportedException"/> whenever the user attempts 
        /// to add an element that is already contained in the <b>ORDERS_FindRowCollection</b>.
        /// </para><para>
        /// <strong>Note:</strong> The <b>Unique</b> wrapper reflects any changes made
        /// to the underlying <paramref name="collection"/>, including the possible
        /// creation of duplicate elements. The uniqueness of all elements is therefore
        /// no longer assured if the underlying collection is manipulated directly.
        /// </para></remarks>

        public static ORDERS_FindRowCollection Unique(ORDERS_FindRowCollection collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            for (int i = collection.Count - 1; i > 0; i--)
                if (collection.IndexOf(collection[i]) < i)
                    throw new ArgumentException("collection",
                        "Argument cannot contain duplicate elements.");

            return new UniqueList(collection);
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckEnumIndex

        private void CheckEnumIndex(int index) {
            if (index < 0 || index >= this._count)
                throw new InvalidOperationException(
                    "Enumerator is not on a collection element.");
        }

        #endregion
        #region CheckEnumVersion

        private void CheckEnumVersion(int version) {
            if (version != this._version)
                throw new InvalidOperationException(
                    "Enumerator invalidated by modification to collection.");
        }

        #endregion
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #region EnsureCapacity

        private void EnsureCapacity(int minimum) {
            int newCapacity = (this._array.Length == 0 ?
                _defaultCapacity : this._array.Length * 2);

            if (newCapacity < minimum) newCapacity = minimum;
            Capacity = newCapacity;
        }

        #endregion
        #region ValidateIndex

        private void ValidateIndex(int index) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (index >= this._count)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument must be less than Count.");
        }

        #endregion
        #endregion
        #region Class Enumerator

        [Serializable]
        private sealed class Enumerator:
            IORDERS_FindRowEnumerator, IEnumerator {
            #region Private Fields

            private readonly ORDERS_FindRowCollection _collection;
            private readonly int _version;
            private int _index;

            #endregion
            #region Internal Constructors

            internal Enumerator(ORDERS_FindRowCollection collection) {
                this._collection = collection;
                this._version = collection._version;
                this._index = -1;
            }

            #endregion
            #region Public Properties

            public ORDERS_FindRow Current {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);
                    return this._collection[this._index];
                }
            }

            object IEnumerator.Current {
                get { return Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                this._collection.CheckEnumVersion(this._version);
                return (++this._index < this._collection.Count);
            }

            public void Reset() {
                this._collection.CheckEnumVersion(this._version);
                this._index = -1;
            }

            #endregion
        }

        #endregion
        #region Class ReadOnlyList

        [Serializable]
        private sealed class ReadOnlyList: ORDERS_FindRowCollection {
            #region Private Fields

            private ORDERS_FindRowCollection _collection;

            #endregion
            #region Internal Constructors

            internal ReadOnlyList(ORDERS_FindRowCollection collection):
                base(Tag.Default) {
                this._collection = collection;
            }

            #endregion
            #region Protected Properties

            protected override ORDERS_FindRow[] InnerArray {
                get { return this._collection.InnerArray; }
            }

            #endregion
            #region Public Properties

            public override int Capacity {
                get { return this._collection.Capacity; }
                set { throw new NotSupportedException(
                        "Read-only collections cannot be modified."); }
            }

            public override int Count {
                get { return this._collection.Count; }
            }

            public override bool IsFixedSize {
                get { return true; }
            }

            public override bool IsReadOnly {
                get { return true; }
            }

            public override bool IsSynchronized {
                get { return this._collection.IsSynchronized; }
            }

            public override bool IsUnique {
                get { return this._collection.IsUnique; }
            }

            public override ORDERS_FindRow this[int index] {
                get { return this._collection[index]; }
                set { throw new NotSupportedException(
                        "Read-only collections cannot be modified."); }
            }

            public override object SyncRoot {
                get { return this._collection.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public override int Add(ORDERS_FindRow value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void AddRange(ORDERS_FindRowCollection collection) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void AddRange(ORDERS_FindRow[] array) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override int BinarySearch(ORDERS_FindRow value) {
                return this._collection.BinarySearch(value);
            }

            public override void Clear() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override object Clone() {
                return new ReadOnlyList((ORDERS_FindRowCollection) this._collection.Clone());
            }

            public override void CopyTo(ORDERS_FindRow[] array) {
                this._collection.CopyTo(array);
            }

            public override void CopyTo(ORDERS_FindRow[] array, int arrayIndex) {
                this._collection.CopyTo(array, arrayIndex);
            }

            public override IORDERS_FindRowEnumerator GetEnumerator() {
                return this._collection.GetEnumerator();
            }

            public override int IndexOf(ORDERS_FindRow value) {
                return this._collection.IndexOf(value);
            }

            public override void Insert(int index, ORDERS_FindRow value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Remove(ORDERS_FindRow value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void RemoveAt(int index) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void RemoveRange(int index, int count) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Reverse() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Reverse(int index, int count) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Sort() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Sort(IComparer comparer) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override void Sort(int index, int count, IComparer comparer) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public override ORDERS_FindRow[] ToArray() {
                return this._collection.ToArray();
            }

            public override void TrimToSize() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            #endregion
        }

        #endregion
        #region Class SyncList

        [Serializable]
        private sealed class SyncList: ORDERS_FindRowCollection {
            #region Private Fields

            private ORDERS_FindRowCollection _collection;
            private object _root;

            #endregion
            #region Internal Constructors

            internal SyncList(ORDERS_FindRowCollection collection):
                base(Tag.Default) {

                this._root = collection.SyncRoot;
                this._collection = collection;
            }

            #endregion
            #region Protected Properties

            protected override ORDERS_FindRow[] InnerArray {
                get { lock (this._root) return this._collection.InnerArray; }
            }

            #endregion
            #region Public Properties

            public override int Capacity {
                get { lock (this._root) return this._collection.Capacity; }
                set { lock (this._root) this._collection.Capacity = value; }
            }

            public override int Count {
                get { lock (this._root) return this._collection.Count; }
            }

            public override bool IsFixedSize {
                get { return this._collection.IsFixedSize; }
            }

            public override bool IsReadOnly {
                get { return this._collection.IsReadOnly; }
            }

            public override bool IsSynchronized {
                get { return true; }
            }

            public override bool IsUnique {
                get { return this._collection.IsUnique; }
            }

            public override ORDERS_FindRow this[int index] {
                get { lock (this._root) return this._collection[index]; }
                set { lock (this._root) this._collection[index] = value;  }
            }

            public override object SyncRoot {
                get { return this._root; }
            }

            #endregion
            #region Public Methods

            public override int Add(ORDERS_FindRow value) {
                lock (this._root) return this._collection.Add(value);
            }

            public override void AddRange(ORDERS_FindRowCollection collection) {
                lock (this._root) this._collection.AddRange(collection);
            }

            public override void AddRange(ORDERS_FindRow[] array) {
                lock (this._root) this._collection.AddRange(array);
            }

            public override int BinarySearch(ORDERS_FindRow value) {
                lock (this._root) return this._collection.BinarySearch(value);
            }

            public override void Clear() {
                lock (this._root) this._collection.Clear();
            }

            public override object Clone() {
                lock (this._root)
                    return new SyncList((ORDERS_FindRowCollection) this._collection.Clone());
            }

            public override void CopyTo(ORDERS_FindRow[] array) {
                lock (this._root) this._collection.CopyTo(array);
            }

            public override void CopyTo(ORDERS_FindRow[] array, int arrayIndex) {
                lock (this._root) this._collection.CopyTo(array, arrayIndex);
            }

            public override IORDERS_FindRowEnumerator GetEnumerator() {
                lock (this._root) return this._collection.GetEnumerator();
            }

            public override int IndexOf(ORDERS_FindRow value) {
                lock (this._root) return this._collection.IndexOf(value);
            }

            public override void Insert(int index, ORDERS_FindRow value) {
                lock (this._root) this._collection.Insert(index, value);
            }

            public override void Remove(ORDERS_FindRow value) {
                lock (this._root) this._collection.Remove(value);
            }

            public override void RemoveAt(int index) {
                lock (this._root) this._collection.RemoveAt(index);
            }

            public override void RemoveRange(int index, int count) {
                lock (this._root) this._collection.RemoveRange(index, count);
            }

            public override void Reverse() {
                lock (this._root) this._collection.Reverse();
            }

            public override void Reverse(int index, int count) {
                lock (this._root) this._collection.Reverse(index, count);
            }

            public override void Sort() {
                lock (this._root) this._collection.Sort();
            }

            public override void Sort(IComparer comparer) {
                lock (this._root) this._collection.Sort(comparer);
            }

            public override void Sort(int index, int count, IComparer comparer) {
                lock (this._root) this._collection.Sort(index, count, comparer);
            }

            public override ORDERS_FindRow[] ToArray() {
                lock (this._root) return this._collection.ToArray();
            }

            public override void TrimToSize() {
                lock (this._root) this._collection.TrimToSize();
            }

            #endregion
        }

        #endregion
        #region Class UniqueList

        [Serializable]
        private sealed class UniqueList: ORDERS_FindRowCollection {
            #region Private Fields

            private ORDERS_FindRowCollection _collection;

            #endregion
            #region Internal Constructors

            internal UniqueList(ORDERS_FindRowCollection collection):
                base(Tag.Default) {
                this._collection = collection;
            }

            #endregion
            #region Protected Properties

            protected override ORDERS_FindRow[] InnerArray {
                get { return this._collection.InnerArray; }
            }

            #endregion
            #region Public Properties

            public override int Capacity {
                get { return this._collection.Capacity; }
                set { this._collection.Capacity = value; }
            }

            public override int Count {
                get { return this._collection.Count; }
            }

            public override bool IsFixedSize {
                get { return this._collection.IsFixedSize; }
            }

            public override bool IsReadOnly {
                get { return this._collection.IsReadOnly; }
            }

            public override bool IsSynchronized {
                get { return this._collection.IsSynchronized; }
            }

            public override bool IsUnique {
                get { return true; }
            }

            public override ORDERS_FindRow this[int index] {
                get { return this._collection[index]; }
                set {
                    CheckUnique(index, value);
                    this._collection[index] = value;
                }
            }

            public override object SyncRoot {
                get { return this._collection.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public override int Add(ORDERS_FindRow value) {
                CheckUnique(value);
                return this._collection.Add(value);
            }

            public override void AddRange(ORDERS_FindRowCollection collection) {
                foreach (ORDERS_FindRow value in collection)
                    CheckUnique(value);
            
                this._collection.AddRange(collection);
            }

            public override void AddRange(ORDERS_FindRow[] array) {
                foreach (ORDERS_FindRow value in array)
                    CheckUnique(value);
            
                this._collection.AddRange(array);
            }

            public override int BinarySearch(ORDERS_FindRow value) {
                return this._collection.BinarySearch(value);
            }

            public override void Clear() {
                this._collection.Clear();
            }

            public override object Clone() {
                return new UniqueList((ORDERS_FindRowCollection) this._collection.Clone());
            }

            public override void CopyTo(ORDERS_FindRow[] array) {
                this._collection.CopyTo(array);
            }

            public override void CopyTo(ORDERS_FindRow[] array, int arrayIndex) {
                this._collection.CopyTo(array, arrayIndex);
            }

            public override IORDERS_FindRowEnumerator GetEnumerator() {
                return this._collection.GetEnumerator();
            }

            public override int IndexOf(ORDERS_FindRow value) {
                return this._collection.IndexOf(value);
            }

            public override void Insert(int index, ORDERS_FindRow value) {
                CheckUnique(value);
                this._collection.Insert(index, value);
            }

            public override void Remove(ORDERS_FindRow value) {
                this._collection.Remove(value);
            }

            public override void RemoveAt(int index) {
                this._collection.RemoveAt(index);
            }

            public override void RemoveRange(int index, int count) {
                this._collection.RemoveRange(index, count);
            }

            public override void Reverse() {
                this._collection.Reverse();
            }

            public override void Reverse(int index, int count) {
                this._collection.Reverse(index, count);
            }

            public override void Sort() {
                this._collection.Sort();
            }

            public override void Sort(IComparer comparer) {
                this._collection.Sort(comparer);
            }

            public override void Sort(int index, int count, IComparer comparer) {
                this._collection.Sort(index, count, comparer);
            }

            public override ORDERS_FindRow[] ToArray() {
                return this._collection.ToArray();
            }

            public override void TrimToSize() {
                this._collection.TrimToSize();
            }

            #endregion
            #region Private Methods

            private void CheckUnique(ORDERS_FindRow value) {
                if (IndexOf(value) >= 0)
                    throw new NotSupportedException(
                        "Unique collections cannot contain duplicate elements.");
            }

            private void CheckUnique(int index, ORDERS_FindRow value) {
                int existing = IndexOf(value);
                if (existing >= 0 && existing != index)
                    throw new NotSupportedException(
                        "Unique collections cannot contain duplicate elements.");
            }

            #endregion
        }

        #endregion
    }

    #endregion
	#endregion
	
	#region ORDERS_FindRow
	/// <summary>
	/// Stores result row level information from the ORDERS_Find stored procedure.
	/// </summary>
	[Serializable]
	public class ORDERS_FindRow
	{
		#region Member Variables
		protected SqlInt32 _orderId = SqlInt32.Null;
		protected SqlInt32 _orderKind = SqlInt32.Null;
		protected SqlInt32 _customerId = SqlInt32.Null;
		protected SqlString _createdBy = SqlString.Null;
		protected SqlDateTime _createdDate = SqlDateTime.Null;
		protected SqlString _modifiedBy = SqlString.Null;
		protected SqlDateTime _modifiedDate = SqlDateTime.Null;
		protected SqlDecimal _total = SqlDecimal.Null;
		protected SqlDecimal _pay = SqlDecimal.Null;
		protected SqlInt32 _status = SqlInt32.Null;
		protected SqlString _note = SqlString.Null;
		#endregion
		
		#region Constructors
		public ORDERS_FindRow()
		{
		}
		
		public ORDERS_FindRow(SqlDataReader reader)
		{
			this.LoadFromReader(reader);
		}
		#endregion
		
		#region Helper Methods
		protected void LoadFromReader(SqlDataReader reader)
		{
			if (reader != null && !reader.IsClosed)
			{
				if (!reader.IsDBNull(0)) _orderId = reader.GetInt32(0);
				if (!reader.IsDBNull(1)) _orderKind = reader.GetInt32(1);
				if (!reader.IsDBNull(2)) _customerId = reader.GetInt32(2);
				if (!reader.IsDBNull(3)) _createdBy = reader.GetString(3);
				if (!reader.IsDBNull(4)) _createdDate = reader.GetDateTime(4);
				if (!reader.IsDBNull(5)) _modifiedBy = reader.GetString(5);
				if (!reader.IsDBNull(6)) _modifiedDate = reader.GetDateTime(6);
				if (!reader.IsDBNull(7)) _total = reader.GetDecimal(7);
				if (!reader.IsDBNull(8)) _pay = reader.GetDecimal(8);
				if (!reader.IsDBNull(9)) _status = reader.GetInt32(9);
				if (!reader.IsDBNull(10)) _note = reader.GetString(10);
			}
		}
		#endregion
		
		#region Public Properties
		public SqlInt32 OrderId
		{
			get {return _orderId;}
			set {_orderId = value;}
		}

		public SqlInt32 OrderKind
		{
			get {return _orderKind;}
			set {_orderKind = value;}
		}

		public SqlInt32 CustomerId
		{
			get {return _customerId;}
			set {_customerId = value;}
		}

		public SqlString CreatedBy
		{
			get {return _createdBy;}
			set {_createdBy = value;}
		}

		public SqlDateTime CreatedDate
		{
			get {return _createdDate;}
			set {_createdDate = value;}
		}

		public SqlString ModifiedBy
		{
			get {return _modifiedBy;}
			set {_modifiedBy = value;}
		}

		public SqlDateTime ModifiedDate
		{
			get {return _modifiedDate;}
			set {_modifiedDate = value;}
		}

		public SqlDecimal Total
		{
			get {return _total;}
			set {_total = value;}
		}

		public SqlDecimal Pay
		{
			get {return _pay;}
			set {_pay = value;}
		}

		public SqlInt32 Status
		{
			get {return _status;}
			set {_status = value;}
		}

		public SqlString Note
		{
			get {return _note;}
			set {_note = value;}
		}
		#endregion
	}
	#endregion
	
	#region ORDERS_Find Wrapper
    /// <summary>
    /// This class is a wrapper for the ORDERS_Find stored procedure.
    /// </summary>
    public class ORDERS_Find
    {
		#region Member Variables
		protected string _connectionString = String.Empty;
		protected int _recordsAffected = -1;
		protected int _returnValue = 0;
		protected SqlBoolean _searchUsingOR = SqlBoolean.Null;
		protected bool _searchUsingORSet = false;
		protected SqlInt32 _orderId = SqlInt32.Null;
		protected bool _orderIdSet = false;
		protected SqlInt32 _orderKind = SqlInt32.Null;
		protected bool _orderKindSet = false;
		protected SqlInt32 _customerId = SqlInt32.Null;
		protected bool _customerIdSet = false;
		protected SqlString _createdBy = SqlString.Null;
		protected bool _createdBySet = false;
		protected SqlDateTime _createdDate = SqlDateTime.Null;
		protected bool _createdDateSet = false;
		protected SqlString _modifiedBy = SqlString.Null;
		protected bool _modifiedBySet = false;
		protected SqlDateTime _modifiedDate = SqlDateTime.Null;
		protected bool _modifiedDateSet = false;
		protected SqlDecimal _total = SqlDecimal.Null;
		protected bool _totalSet = false;
		protected SqlDecimal _pay = SqlDecimal.Null;
		protected bool _paySet = false;
		protected SqlInt32 _status = SqlInt32.Null;
		protected bool _statusSet = false;
		protected SqlString _note = SqlString.Null;
		protected bool _noteSet = false;
		#endregion
		
		#region Constructors
		public ORDERS_Find()
		{
		}
		
		public ORDERS_Find(string connectionString)
		{
			this.ConnectionString = connectionString;
		}
		#endregion
		
		#region Public Properties
		/// <summary>
		/// The connection string to use when executing the ORDERS_Find stored procedure.
		/// </summary>
		public string ConnectionString
		{
			get {return _connectionString;}
			set {_connectionString = value;}
		}
		
		/// <summary>
		/// Gets the return value from the ORDERS_Find stored procedure.
		/// </summary>
		public int ReturnValue
		{
			get {return _returnValue;}
		}
		
		/// <summary>
		/// Gets the number of rows changed, inserted, or deleted by execution of the ORDERS_Find stored procedure.
		/// </summary>
		public int RecordsAffected
		{
			get {return _recordsAffected;}
		}
		
		/// <summary>
		/// 
		/// </summary>
		public SqlBoolean SearchUsingOR
		{
			get {return _searchUsingOR;}
			set
			{
				_searchUsingOR = value;
				_searchUsingORSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlInt32 OrderId
		{
			get {return _orderId;}
			set
			{
				_orderId = value;
				_orderIdSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlInt32 OrderKind
		{
			get {return _orderKind;}
			set
			{
				_orderKind = value;
				_orderKindSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlInt32 CustomerId
		{
			get {return _customerId;}
			set
			{
				_customerId = value;
				_customerIdSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlString CreatedBy
		{
			get {return _createdBy;}
			set
			{
				_createdBy = value;
				_createdBySet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlDateTime CreatedDate
		{
			get {return _createdDate;}
			set
			{
				_createdDate = value;
				_createdDateSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlString ModifiedBy
		{
			get {return _modifiedBy;}
			set
			{
				_modifiedBy = value;
				_modifiedBySet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlDateTime ModifiedDate
		{
			get {return _modifiedDate;}
			set
			{
				_modifiedDate = value;
				_modifiedDateSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlDecimal Total
		{
			get {return _total;}
			set
			{
				_total = value;
				_totalSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlDecimal Pay
		{
			get {return _pay;}
			set
			{
				_pay = value;
				_paySet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlInt32 Status
		{
			get {return _status;}
			set
			{
				_status = value;
				_statusSet = true;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public SqlString Note
		{
			get {return _note;}
			set
			{
				_note = value;
				_noteSet = true;
			}
		}
		#endregion
		
		#region Execute Methods
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and returns a SqlDataReader with the results.
		/// </summary>
		/// <returns>SqlDataReader</returns>
		public virtual SqlDataReader ExecuteReader()
		{
			SqlDataReader reader = null;
			SqlCommand cmd = new SqlCommand();
			
			System.Diagnostics.Debug.Assert(this.ConnectionString.Length != 0, "You must first set the ConnectionString property before calling this method.");
			SqlConnection cn = new SqlConnection(this.ConnectionString);
			
			try
			{
				cmd.Connection = cn;
				cmd.CommandText = "[dbo].[ORDERS_Find]";
				cmd.CommandType = CommandType.StoredProcedure;
				
				#region Populate Parameters
				SqlParameter prmReturnValue = cmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
				prmReturnValue.Direction = ParameterDirection.ReturnValue;
				
				SqlParameter prmSearchUsingOR = cmd.Parameters.Add("@SearchUsingOR", SqlDbType.Bit);
				prmSearchUsingOR.Direction = ParameterDirection.Input;
				if (_searchUsingORSet == true || this.SearchUsingOR.IsNull == false)
				{
					prmSearchUsingOR.Value = this.SearchUsingOR;
				}
				
				SqlParameter prmOrderId = cmd.Parameters.Add("@OrderId", SqlDbType.Int);
				prmOrderId.Direction = ParameterDirection.Input;
				if (_orderIdSet == true || this.OrderId.IsNull == false)
				{
					prmOrderId.Value = this.OrderId;
				}
				
				SqlParameter prmOrderKind = cmd.Parameters.Add("@OrderKind", SqlDbType.Int);
				prmOrderKind.Direction = ParameterDirection.Input;
				if (_orderKindSet == true || this.OrderKind.IsNull == false)
				{
					prmOrderKind.Value = this.OrderKind;
				}
				
				SqlParameter prmCustomerId = cmd.Parameters.Add("@CustomerId", SqlDbType.Int);
				prmCustomerId.Direction = ParameterDirection.Input;
				if (_customerIdSet == true || this.CustomerId.IsNull == false)
				{
					prmCustomerId.Value = this.CustomerId;
				}
				
				SqlParameter prmCreatedBy = cmd.Parameters.Add("@CreatedBy", SqlDbType.NVarChar);
				prmCreatedBy.Direction = ParameterDirection.Input;
					prmCreatedBy.Size = 250;
				if (_createdBySet == true || this.CreatedBy.IsNull == false)
				{
					prmCreatedBy.Value = this.CreatedBy;
				}
				
				SqlParameter prmCreatedDate = cmd.Parameters.Add("@CreatedDate", SqlDbType.DateTime);
				prmCreatedDate.Direction = ParameterDirection.Input;
				if (_createdDateSet == true || this.CreatedDate.IsNull == false)
				{
					prmCreatedDate.Value = this.CreatedDate;
				}
				
				SqlParameter prmModifiedBy = cmd.Parameters.Add("@ModifiedBy", SqlDbType.NVarChar);
				prmModifiedBy.Direction = ParameterDirection.Input;
					prmModifiedBy.Size = 250;
				if (_modifiedBySet == true || this.ModifiedBy.IsNull == false)
				{
					prmModifiedBy.Value = this.ModifiedBy;
				}
				
				SqlParameter prmModifiedDate = cmd.Parameters.Add("@ModifiedDate", SqlDbType.DateTime);
				prmModifiedDate.Direction = ParameterDirection.Input;
				if (_modifiedDateSet == true || this.ModifiedDate.IsNull == false)
				{
					prmModifiedDate.Value = this.ModifiedDate;
				}
				
				SqlParameter prmTotal = cmd.Parameters.Add("@Total", SqlDbType.Decimal);
				prmTotal.Direction = ParameterDirection.Input;
					prmTotal.Precision = 18;
					prmTotal.Scale = 0;
				if (_totalSet == true || this.Total.IsNull == false)
				{
					prmTotal.Value = this.Total;
				}
				
				SqlParameter prmPay = cmd.Parameters.Add("@Pay", SqlDbType.Decimal);
				prmPay.Direction = ParameterDirection.Input;
					prmPay.Precision = 18;
					prmPay.Scale = 0;
				if (_paySet == true || this.Pay.IsNull == false)
				{
					prmPay.Value = this.Pay;
				}
				
				SqlParameter prmStatus = cmd.Parameters.Add("@Status", SqlDbType.Int);
				prmStatus.Direction = ParameterDirection.Input;
				if (_statusSet == true || this.Status.IsNull == false)
				{
					prmStatus.Value = this.Status;
				}
				
				SqlParameter prmNote = cmd.Parameters.Add("@Note", SqlDbType.Text);
				prmNote.Direction = ParameterDirection.Input;
					prmNote.Size = 16;
				if (_noteSet == true || this.Note.IsNull == false)
				{
					prmNote.Value = this.Note;
				}
				#endregion
				
				#region Execute Command
				cn.Open();
				reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);
				#endregion
				
				#region Get Output Parameters
				if (prmReturnValue.Value != null && prmReturnValue.Value != DBNull.Value)
				{
					_returnValue = (int)prmReturnValue.Value;
				}
				
				#endregion
			}
			finally
			{
				cmd.Dispose();
			}
			
			return reader;
		}
		
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and returns a DataSet with the results.
		/// </summary>
		/// <returns>DataSet</returns>
		public virtual DataSet ExecuteDataSet()
		{
			DataSet ds = new DataSet();
			SqlCommand cmd = new SqlCommand();
			
			System.Diagnostics.Debug.Assert(this.ConnectionString.Length != 0, "You must first set the ConnectionString property before calling this method.");
			SqlConnection cn = new SqlConnection(this.ConnectionString);
			
			try
			{
				cmd.Connection = cn;
				cmd.CommandText = "[dbo].[ORDERS_Find]";
				cmd.CommandType = CommandType.StoredProcedure;
				
				#region Populate Parameters
				SqlParameter prmReturnValue = cmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
				prmReturnValue.Direction = ParameterDirection.ReturnValue;
				
				SqlParameter prmSearchUsingOR = cmd.Parameters.Add("@SearchUsingOR", SqlDbType.Bit);
				prmSearchUsingOR.Direction = ParameterDirection.Input;
				if (_searchUsingORSet == true || this.SearchUsingOR.IsNull == false)
				{
					prmSearchUsingOR.Value = this.SearchUsingOR;
				}
				
				SqlParameter prmOrderId = cmd.Parameters.Add("@OrderId", SqlDbType.Int);
				prmOrderId.Direction = ParameterDirection.Input;
				if (_orderIdSet == true || this.OrderId.IsNull == false)
				{
					prmOrderId.Value = this.OrderId;
				}
				
				SqlParameter prmOrderKind = cmd.Parameters.Add("@OrderKind", SqlDbType.Int);
				prmOrderKind.Direction = ParameterDirection.Input;
				if (_orderKindSet == true || this.OrderKind.IsNull == false)
				{
					prmOrderKind.Value = this.OrderKind;
				}
				
				SqlParameter prmCustomerId = cmd.Parameters.Add("@CustomerId", SqlDbType.Int);
				prmCustomerId.Direction = ParameterDirection.Input;
				if (_customerIdSet == true || this.CustomerId.IsNull == false)
				{
					prmCustomerId.Value = this.CustomerId;
				}
				
				SqlParameter prmCreatedBy = cmd.Parameters.Add("@CreatedBy", SqlDbType.NVarChar);
				prmCreatedBy.Direction = ParameterDirection.Input;
					prmCreatedBy.Size = 250;
				if (_createdBySet == true || this.CreatedBy.IsNull == false)
				{
					prmCreatedBy.Value = this.CreatedBy;
				}
				
				SqlParameter prmCreatedDate = cmd.Parameters.Add("@CreatedDate", SqlDbType.DateTime);
				prmCreatedDate.Direction = ParameterDirection.Input;
				if (_createdDateSet == true || this.CreatedDate.IsNull == false)
				{
					prmCreatedDate.Value = this.CreatedDate;
				}
				
				SqlParameter prmModifiedBy = cmd.Parameters.Add("@ModifiedBy", SqlDbType.NVarChar);
				prmModifiedBy.Direction = ParameterDirection.Input;
					prmModifiedBy.Size = 250;
				if (_modifiedBySet == true || this.ModifiedBy.IsNull == false)
				{
					prmModifiedBy.Value = this.ModifiedBy;
				}
				
				SqlParameter prmModifiedDate = cmd.Parameters.Add("@ModifiedDate", SqlDbType.DateTime);
				prmModifiedDate.Direction = ParameterDirection.Input;
				if (_modifiedDateSet == true || this.ModifiedDate.IsNull == false)
				{
					prmModifiedDate.Value = this.ModifiedDate;
				}
				
				SqlParameter prmTotal = cmd.Parameters.Add("@Total", SqlDbType.Decimal);
				prmTotal.Direction = ParameterDirection.Input;
					prmTotal.Precision = 18;
					prmTotal.Scale = 0;
				if (_totalSet == true || this.Total.IsNull == false)
				{
					prmTotal.Value = this.Total;
				}
				
				SqlParameter prmPay = cmd.Parameters.Add("@Pay", SqlDbType.Decimal);
				prmPay.Direction = ParameterDirection.Input;
					prmPay.Precision = 18;
					prmPay.Scale = 0;
				if (_paySet == true || this.Pay.IsNull == false)
				{
					prmPay.Value = this.Pay;
				}
				
				SqlParameter prmStatus = cmd.Parameters.Add("@Status", SqlDbType.Int);
				prmStatus.Direction = ParameterDirection.Input;
				if (_statusSet == true || this.Status.IsNull == false)
				{
					prmStatus.Value = this.Status;
				}
				
				SqlParameter prmNote = cmd.Parameters.Add("@Note", SqlDbType.Text);
				prmNote.Direction = ParameterDirection.Input;
					prmNote.Size = 16;
				if (_noteSet == true || this.Note.IsNull == false)
				{
					prmNote.Value = this.Note;
				}
				#endregion
				
				#region Execute Command
				cn.Open();
				
				SqlDataAdapter da = new SqlDataAdapter(cmd);
				da.Fill(ds);
				_recordsAffected = ds.Tables[0].Rows.Count;
				#endregion
				
				#region Get Output Parameters
				if (prmReturnValue.Value != null && prmReturnValue.Value != DBNull.Value)
				{
					_returnValue = (int)prmReturnValue.Value;
				}
				
				#endregion
			}
			finally
			{
				if (cn.State == ConnectionState.Open)
				{
					cn.Close();
				}
				
				cn.Dispose();
				cmd.Dispose();
			}
			
			return ds;
		}
		
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and outputs the results to a custom strongly typed collection.
		/// </summary>
		/// <returns>ORDERS_FindRowCollection</returns>
		public virtual ORDERS_FindRowCollection Execute()
		{
			ORDERS_FindRowCollection oRDERS_FindRowCollection = new ORDERS_FindRowCollection();
			SqlCommand cmd = new SqlCommand();
			
			System.Diagnostics.Debug.Assert(this.ConnectionString.Length != 0, "You must first set the ConnectionString property before calling this method.");
			SqlConnection cn = new SqlConnection(this.ConnectionString);
			
			try
			{
				cmd.Connection = cn;
				cmd.CommandText = "[dbo].[ORDERS_Find]";
				cmd.CommandType = CommandType.StoredProcedure;
				
				#region Populate Parameters
				SqlParameter prmReturnValue = cmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
				prmReturnValue.Direction = ParameterDirection.ReturnValue;
				
				SqlParameter prmSearchUsingOR = cmd.Parameters.Add("@SearchUsingOR", SqlDbType.Bit);
				prmSearchUsingOR.Direction = ParameterDirection.Input;
				if (_searchUsingORSet == true || this.SearchUsingOR.IsNull == false)
				{
					prmSearchUsingOR.Value = this.SearchUsingOR;
				}
				
				SqlParameter prmOrderId = cmd.Parameters.Add("@OrderId", SqlDbType.Int);
				prmOrderId.Direction = ParameterDirection.Input;
				if (_orderIdSet == true || this.OrderId.IsNull == false)
				{
					prmOrderId.Value = this.OrderId;
				}
				
				SqlParameter prmOrderKind = cmd.Parameters.Add("@OrderKind", SqlDbType.Int);
				prmOrderKind.Direction = ParameterDirection.Input;
				if (_orderKindSet == true || this.OrderKind.IsNull == false)
				{
					prmOrderKind.Value = this.OrderKind;
				}
				
				SqlParameter prmCustomerId = cmd.Parameters.Add("@CustomerId", SqlDbType.Int);
				prmCustomerId.Direction = ParameterDirection.Input;
				if (_customerIdSet == true || this.CustomerId.IsNull == false)
				{
					prmCustomerId.Value = this.CustomerId;
				}
				
				SqlParameter prmCreatedBy = cmd.Parameters.Add("@CreatedBy", SqlDbType.NVarChar);
				prmCreatedBy.Direction = ParameterDirection.Input;
					prmCreatedBy.Size = 250;
				if (_createdBySet == true || this.CreatedBy.IsNull == false)
				{
					prmCreatedBy.Value = this.CreatedBy;
				}
				
				SqlParameter prmCreatedDate = cmd.Parameters.Add("@CreatedDate", SqlDbType.DateTime);
				prmCreatedDate.Direction = ParameterDirection.Input;
				if (_createdDateSet == true || this.CreatedDate.IsNull == false)
				{
					prmCreatedDate.Value = this.CreatedDate;
				}
				
				SqlParameter prmModifiedBy = cmd.Parameters.Add("@ModifiedBy", SqlDbType.NVarChar);
				prmModifiedBy.Direction = ParameterDirection.Input;
					prmModifiedBy.Size = 250;
				if (_modifiedBySet == true || this.ModifiedBy.IsNull == false)
				{
					prmModifiedBy.Value = this.ModifiedBy;
				}
				
				SqlParameter prmModifiedDate = cmd.Parameters.Add("@ModifiedDate", SqlDbType.DateTime);
				prmModifiedDate.Direction = ParameterDirection.Input;
				if (_modifiedDateSet == true || this.ModifiedDate.IsNull == false)
				{
					prmModifiedDate.Value = this.ModifiedDate;
				}
				
				SqlParameter prmTotal = cmd.Parameters.Add("@Total", SqlDbType.Decimal);
				prmTotal.Direction = ParameterDirection.Input;
					prmTotal.Precision = 18;
					prmTotal.Scale = 0;
				if (_totalSet == true || this.Total.IsNull == false)
				{
					prmTotal.Value = this.Total;
				}
				
				SqlParameter prmPay = cmd.Parameters.Add("@Pay", SqlDbType.Decimal);
				prmPay.Direction = ParameterDirection.Input;
					prmPay.Precision = 18;
					prmPay.Scale = 0;
				if (_paySet == true || this.Pay.IsNull == false)
				{
					prmPay.Value = this.Pay;
				}
				
				SqlParameter prmStatus = cmd.Parameters.Add("@Status", SqlDbType.Int);
				prmStatus.Direction = ParameterDirection.Input;
				if (_statusSet == true || this.Status.IsNull == false)
				{
					prmStatus.Value = this.Status;
				}
				
				SqlParameter prmNote = cmd.Parameters.Add("@Note", SqlDbType.Text);
				prmNote.Direction = ParameterDirection.Input;
					prmNote.Size = 16;
				if (_noteSet == true || this.Note.IsNull == false)
				{
					prmNote.Value = this.Note;
				}
				#endregion
				
				#region Execute Command
				cn.Open();
				SqlDataReader reader = cmd.ExecuteReader();
				try
				{
					while (reader.Read())
					{
						ORDERS_FindRow oRDERS_FindRow = new ORDERS_FindRow(reader);
						oRDERS_FindRowCollection.Add(oRDERS_FindRow);
					}
				}
				finally
				{
					if (!reader.IsClosed)
					{
						reader.Close();
						_recordsAffected = reader.RecordsAffected;
					}
				}
				#endregion
				
				#region Get Output Parameters
				if (prmReturnValue.Value != null && prmReturnValue.Value != DBNull.Value)
				{
					_returnValue = (int)prmReturnValue.Value;
				}
				
				#endregion
			}
			finally
			{
				if (cn.State == ConnectionState.Open)
				{
					cn.Close();
				}
				
				cn.Dispose();
				cmd.Dispose();
			}
			
			return oRDERS_FindRowCollection;
		}
		
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and returns a SqlDataReader with the results.
		/// </summary>
		/// <param name="connectionString">The connection string to use</param>
		/// <param name="searchUsingOR"></param>
		/// <param name="orderId"></param>
		/// <param name="orderKind"></param>
		/// <param name="customerId"></param>
		/// <param name="createdBy"></param>
		/// <param name="createdDate"></param>
		/// <param name="modifiedBy"></param>
		/// <param name="modifiedDate"></param>
		/// <param name="total"></param>
		/// <param name="pay"></param>
		/// <param name="status"></param>
		/// <param name="note"></param>
		/// <returns>SqlDataReader</returns>
		public static SqlDataReader ExecuteReader(
				#region Parameters
				string connectionString,
				SqlBoolean searchUsingOR,
				SqlInt32 orderId,
				SqlInt32 orderKind,
				SqlInt32 customerId,
				SqlString createdBy,
				SqlDateTime createdDate,
				SqlString modifiedBy,
				SqlDateTime modifiedDate,
				SqlDecimal total,
				SqlDecimal pay,
				SqlInt32 status,
				SqlString note
				#endregion
		    )
		{
			ORDERS_Find oRDERS_Find = new ORDERS_Find();
			
			#region Assign Property Values
			oRDERS_Find.ConnectionString = connectionString;
			oRDERS_Find.SearchUsingOR = searchUsingOR;
			oRDERS_Find.OrderId = orderId;
			oRDERS_Find.OrderKind = orderKind;
			oRDERS_Find.CustomerId = customerId;
			oRDERS_Find.CreatedBy = createdBy;
			oRDERS_Find.CreatedDate = createdDate;
			oRDERS_Find.ModifiedBy = modifiedBy;
			oRDERS_Find.ModifiedDate = modifiedDate;
			oRDERS_Find.Total = total;
			oRDERS_Find.Pay = pay;
			oRDERS_Find.Status = status;
			oRDERS_Find.Note = note;
			#endregion
			
			SqlDataReader reader = oRDERS_Find.ExecuteReader();
			
			#region Get Property Values
			
			#endregion
			
			return reader;
		}
		
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and returns a DataSet with the results.
		/// </summary>
		/// <param name="connectionString">The connection string to use</param>
		/// <param name="searchUsingOR"></param>
		/// <param name="orderId"></param>
		/// <param name="orderKind"></param>
		/// <param name="customerId"></param>
		/// <param name="createdBy"></param>
		/// <param name="createdDate"></param>
		/// <param name="modifiedBy"></param>
		/// <param name="modifiedDate"></param>
		/// <param name="total"></param>
		/// <param name="pay"></param>
		/// <param name="status"></param>
		/// <param name="note"></param>
		/// <returns>DataSet</returns>
		public static DataSet ExecuteDataSet(
				#region Parameters
				string connectionString,
				SqlBoolean searchUsingOR,
				SqlInt32 orderId,
				SqlInt32 orderKind,
				SqlInt32 customerId,
				SqlString createdBy,
				SqlDateTime createdDate,
				SqlString modifiedBy,
				SqlDateTime modifiedDate,
				SqlDecimal total,
				SqlDecimal pay,
				SqlInt32 status,
				SqlString note
				#endregion
		    )
		{
			ORDERS_Find oRDERS_Find = new ORDERS_Find();
			
			#region Assign Property Values
			oRDERS_Find.ConnectionString = connectionString;
			oRDERS_Find.SearchUsingOR = searchUsingOR;
			oRDERS_Find.OrderId = orderId;
			oRDERS_Find.OrderKind = orderKind;
			oRDERS_Find.CustomerId = customerId;
			oRDERS_Find.CreatedBy = createdBy;
			oRDERS_Find.CreatedDate = createdDate;
			oRDERS_Find.ModifiedBy = modifiedBy;
			oRDERS_Find.ModifiedDate = modifiedDate;
			oRDERS_Find.Total = total;
			oRDERS_Find.Pay = pay;
			oRDERS_Find.Status = status;
			oRDERS_Find.Note = note;
			#endregion
			
			DataSet ds = oRDERS_Find.ExecuteDataSet();
			
			#region Get Property Values
			
			#endregion
			
			return ds;
		}
		
		/// <summary>
		/// This method calls the ORDERS_Find stored procedure and outputs the results to a custom strongly typed collection.
		/// </summary>
		/// <param name="connectionString">The connection string to use</param>
		/// <param name="searchUsingOR"></param>
		/// <param name="orderId"></param>
		/// <param name="orderKind"></param>
		/// <param name="customerId"></param>
		/// <param name="createdBy"></param>
		/// <param name="createdDate"></param>
		/// <param name="modifiedBy"></param>
		/// <param name="modifiedDate"></param>
		/// <param name="total"></param>
		/// <param name="pay"></param>
		/// <param name="status"></param>
		/// <param name="note"></param>
		/// <returns>ORDERS_FindRowCollection</returns>
		public static ORDERS_FindRowCollection Execute(
				#region Parameters
				string connectionString,
				SqlBoolean searchUsingOR,
				SqlInt32 orderId,
				SqlInt32 orderKind,
				SqlInt32 customerId,
				SqlString createdBy,
				SqlDateTime createdDate,
				SqlString modifiedBy,
				SqlDateTime modifiedDate,
				SqlDecimal total,
				SqlDecimal pay,
				SqlInt32 status,
				SqlString note
				#endregion
		    )
		{
			ORDERS_Find oRDERS_Find = new ORDERS_Find();
			
			#region Assign Property Values
			oRDERS_Find.ConnectionString = connectionString;
			oRDERS_Find.SearchUsingOR = searchUsingOR;
			oRDERS_Find.OrderId = orderId;
			oRDERS_Find.OrderKind = orderKind;
			oRDERS_Find.CustomerId = customerId;
			oRDERS_Find.CreatedBy = createdBy;
			oRDERS_Find.CreatedDate = createdDate;
			oRDERS_Find.ModifiedBy = modifiedBy;
			oRDERS_Find.ModifiedDate = modifiedDate;
			oRDERS_Find.Total = total;
			oRDERS_Find.Pay = pay;
			oRDERS_Find.Status = status;
			oRDERS_Find.Note = note;
			#endregion
			
			ORDERS_FindRowCollection oRDERS_FindRowCollection = oRDERS_Find.Execute();
			
			#region Get Property Values
			
			#endregion
			
			return oRDERS_FindRowCollection;
		}
		#endregion
	}
	#endregion
}
